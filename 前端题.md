1. 小程序的生命周期

生命周期是指一个小程序从创建到销毁的一系列过程.在小程序中 ，通过App()来注册一个小程序 ，通过Page()来注册一个页面.

```
app():
onLaunch 生命周期函数--监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）

onShow 生命周期函数--监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow

onHide 生命周期函数--监听小程序隐藏 当小程序从前台进入后台，会触发 onHide

onError 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息

其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问
ps:onLaunch,onShow会返回一个对象，包含三个参数，path:打开小程序的路径，query:打开小程序页面url携带的参数，scene:场景值。


page():
onLoad 生命周期函数--监听页面加载

onReady 生命周期函数--监听页面初次渲染完成

onShow 生命周期函数--监听页面显示

onHide 生命周期函数--监听页面隐藏

onUnload 生命周期函数--监听页面卸载

ps:小程序为我们提供了全局数据管理 ，在page页面中通过getApp()方法获取app.js实例
注意：
App() 必须在 app.js 中注册，且不能注册多个。
不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。
不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。
通过 getApp() 获取实例之后，不要私自调用生命周期函数。
```



2. vue的双向绑定原理

```
vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，

数据劫持（通过object.defineproperty()定义访问器属性）改变数据存取的默认行为。有三个参数，对象，属性，描述符对象。

  首先将该任务分成几个子任务：

　　 1、输入框以及文本节点与 data 中的数据绑定

　　 2、输入框内容变化时，data 中的数据同步变化。即 view => model 的变化。

　　 3、data 中的数据变化时，文本节点的内容同步变化。即 model => view 的变化。

       要实现任务一，需要对 DOM 进行编译，这里有一个知识点：DocumentFragment。

DocumentFragment（文档片段）可以看作节点容器，它可以包含多个子节点，当我们将它插入到 DOM 中时，只有它的子节点会插入目标节点，所以把它看作一组节点的容器。使用 DocumentFragment 处理节点，速度和性能远远优于直接操作 DOM。Vue 进行编译时，就是将挂载目标的所有子节点劫持（真的是劫持，通过 append 方法，DOM 中的节点会被自动删除）到 DocumentFragment 中，经过一番处理后，再将 DocumentFragment 整体返回插入挂载目标。

  订阅发布模式（又称观察者模式）定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象。

       发布者发出通知 => 主题对象收到通知并推送给订阅者 => 订阅者执行相应操作
```



3. 数组去重

```
JS实现数组去重方法总结(六种方法)
1.es6的set()，自动去重
2.
双层循环，外层循环元素，内层循环时比较值
如果有相同的值则跳过，不相同则push进数组
3.利用splice直接在原数组进行操作
双层循环，外层循环元素，内层循环时比较值
值相同时，则删去这个值
4.利用对象的属性不能相同的特点进行去重
Array.prototype.distinct = function (){
 var arr = this,
  i,
  obj = {},
  result = [],
  len = arr.length;
 for(i = 0; i< arr.length; i++){
  if(!obj[arr[i]]){ //如果能查找到，证明数组元素重复了
   obj[arr[i]] = 1;
   result.push(arr[i]);
  }
 }
 return result;
};
var a = [1,2,3,4,5,6,5,3,2,4,56,4,1,2,1,1,1,1,1,1,];
var b = a.distinct();
console.log(b.toString()); //1,2,3,4,5,6,56
5.数组递归去重
运用递归的思想
先排序，然后从最后开始比较，遇到相同，则删除
6.利用indexOf以及forEach
```



4. var a=[1,2,3];

​    var b=a;

   a=[0,2,3];

  console.log(b);？

var a=[1,2,3];

​    var b=a;

   a.push(3);

  console.log(b);？

```
1.var a=[1,2,3];

    var b=a;

   a=[0,2,3];//开辟了一个新的内存，所以b还是指向原来的内存的对象

  console.log(b);//[1,2,3]
2.var a=[1,2,3];

    var b=a;

   a.push(3);

  console.log(b);//[1,2,3,3]
  浅拷贝，引用类型值，引用类型的值是保存在内存中的对象，javas不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到新变量分配的空间。不同的是，这个值的副本实际是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此改变其中一个变量就会影响另一个变量。
  


```

var a=[1,2,3];
var b=a;
 a.push(3);
 console.log(b);//[1,2,3,3]
  怎么解决让b=[1,2,3],原来的a,换句话是怎样实现深拷贝？


      var a=[1,2,3];
      function getType(obj){
           //tostring会返回对应不同的标签的构造函数
           var toString = Object.prototype.toString;
           var map = {
              '[object Boolean]'  : 'boolean', 
              '[object Number]'   : 'number', 
              '[object String]'   : 'string', 
              '[object Function]' : 'function', 
              '[object Array]'    : 'array', 
              '[object Date]'     : 'date', 
              '[object RegExp]'   : 'regExp', 
              '[object Undefined]': 'undefined',
              '[object Null]'     : 'null', 
              '[object Object]'   : 'object'
          };
          if(obj instanceof Element) {
               return 'element';
          }
          return map[toString.call(obj)];
       }
        function deepClone(data){
           var type = getType(data);
           var obj;
           if(type === 'array'){
               obj = [];
           } else if(type === 'object'){
               obj = {};
           } else {
               //不再具有下一层次
               return data;
           }
           if(type === 'array'){
               for(var i = 0, len = data.length; i < len; i++){
                   obj.push(deepClone(data[i]));
               }
           } else if(type === 'object'){
               for(var key in data){
                   obj[key] = deepClone(data[key]);
               }
           }
           return obj;
       }
       var b=deepClone(a);
       a.push(3);
       console.log(b);

5. 变量提升

   ```
   JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。

   JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。

   JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。

   变量提升即将变量声明提升到它所在作用域的最顶部。

   函数提升：函数声明提升到最顶部。优先于变量提升。

   作用域：JavaScript作为编程语言，最基本的功能之一就是能够存储变量当中的值。而一套设计良好的用来存储变量，并且之后可以方便地找到这些变量的规则，被称为作用域。负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确认当前执行的代码对这些标识符的访问权限。

   ```

6.  class 

   ```
   1.继承：extend
      super:子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
   所以在constructor方法内this不能放在super前。
      可继承原生的构造函数。
      子类的_proto_属性表示构造函数的继承，总是指向父类。
      子类prototype属性的_proto_属性表示方法的继承总是指向prototype属性。
    2.特殊情况
      子类继承object类，不存在任何继承，继承null.
    3.Object.getPrototypeOf()可用于从子类上获取父类。
    4. 子类实例的_proto_属性的_proto_属性指向父类实例的_proto_属性。子类的原型的原型是父类的原型。因此，通过子类实例的 _proto_属性的_proto_属性可以修改父类实例的行为。
   ```

7. es6,set/map

set()自动去重

map():它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

7. vue组件间传值与小程序组件间传值

```
vue组件间传值：
1.父子之间传值通讯：proper
2.子传父：父组件可以使用 v-on监听子组件上 $emit 的变化。这可以允许你很方便的添加事件显性。
this.$emit(event,...args);
/*
* event: 要触发的事件
* args: 将要传给父组件的参数
*/ 
Usage： 
子组件内容：

<template>
<div @click="iclick"></div>
</template>
methods:{
    iclick(){
        let data = {
            a:'data'
        };
        this.$emit('ievent',data,'lalala');
    }
}
父组件内容：

<i-template @ievent = "ievent"></i-template>
methods:{
    ievent(...data){
        console.log('allData:',data);// data为包含传过来所有数据的数组，第一个元素是对象，第二个元素是字符串
    }
}
3.非父子：简单情况下我们可以通过使用一个空的Vue实例作为中央事件总线，管理组件间的通信：
// 将在各处使用该事件中心
// 组件通过它来通信
var eventHub = new Vue()
然后在组件中，可以使用 $emit, $on, $off 分别来分发、监听、取消监听事件：
4.vuex:专用的状态管理层
```

8. 跨域方式

```
1.跨域资源共享（CORS）
基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。
<script type="text/javascript">
    var xhr = new XMLHttpRequest();
    xhr.open("￼GET", "/trigkit4",true);
    xhr.send();
</script>
以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：

<script type="text/javascript">
    var xhr = new XMLHttpRequest();
    xhr.open("￼GET", "http://segmentfault.com/u/trigkit4/",true);
    xhr.send();
</script>
代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。

服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。
 CORS支持所有类型的HTTP请求。
 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。
 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。
2.jsonp
用js动态生成script标签,通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。请求完毕后可以通过调用callback的方式回传结果。所以jsonp是需要服务器端的页面进行相应的配合的。它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况.
3.通过修改document.domain来跨子域
4.使用window.name来进行跨域
5.使用HTML5中新引进的window.postMessage方法来跨域传送数据
6.hash + iframe
在文章最开始提到过 iframe 标签也是不受同源策略限制的标签之一，hash + iframe 的跨域核心思想就是，在 A 源中通过动态改变 iframe 标签的 src 的哈希值，在 B 源中通过 window.onhashchange 来捕获到相应的哈希值。思路不难直接上代码：
7.WebSockets
WebSockets 属于 HTML5 的协议，它的目的是在一个持久连接上建立全双工通信。由于 WebSockets 采用了自定义协议，所以优点是客户端和服务端发送数据量少，缺点是要额外的服务器。
8.反向代理
9.vue-cli proxy代理

```

9. 箭头函数与普通函数的区别，箭头函数作用，里面的this指向哪里

```
1.比普通函数代码量更少，更简洁明了。
2.箭头函数的this指向的对象就是定义时所在的对象，不是使用时所在的对象。普通函数的this指向的对象是基于函数的执行环境绑定的，在全局函数中，this等于window.而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window.
3.普通函数this对象的指向是可变的，但是箭头函数中是固定的。因此，普通函数的apply，call不能改变他的指向。
4.箭头函数不可以当作构造函数，不可以使用new命令。
5.不可以使用argumengt对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。
6.不可使用yield命令，因此箭头函数不能用作generrator函数。
```

10. 把一个数组乱序

```
var a = [1, 2, 3, 4, 5, 6, 7, 8, 9];

var random = function(array) {

    return array.sort(function(){return Math.random() > 0.5});

};

console.log(random(a)); 

```

11. sort()参数有哪些怎么用

```
arrayObject.sort(sortby)
参数	描述
sortby	可选。规定排序顺序。必须是函数。
```

12. 深拷贝和浅拷贝

​       深拷贝：对于对象来说是复制一个对象到另一个新开辟的内存中， 两者的     修改值互不影响。

​       浅拷贝：对于对象来说，只是复制了对象的引用，指针还是指向同一个堆里面存储的对象。

13. static 函数 

    ```
    class的静态方法，加上static 表示该方法不会被实例继承，而是直接通过类调用。父类的静态方法可以被子类继承。可以从super调用。 
    ```

14. ​

15. 单例模式？

    ```
    传统单例模式

    　　保证一个类仅有一个实例，并提供一个访问它的全局访问点。

    实现单例核心思想

    　　无非是用一个变量来标志当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象，接下来我们用JavaScript来强行实现这个思路。
    ```

16. class 中的instance？？？

17. ctx.drawImage(图片，图片剪裁起始坐标x,图片剪裁起始坐标y,被剪裁的图片的宽度，被剪裁的图片的高度，放置在画布的坐标x，放置在画布的坐标y,放置的图片的宽，放置的图片的高)

18. 定义一个变量时不要跟类取一样的名字。会报错，eg:

    ```
        let b=new b();//error

           let B=new b();//对的

          微信浏览器只认识小写的后缀名

    ```

    ​

19. promise

20. vue 适配

    ```
    在项目根目录的index.html 头部加入手机端适配的meta的代码
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    flex+rem或者安装插件lib-flexible+px2rem-loader
    ```

21. 原型/原型链

    ```
    我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，就是原型对象，而这个对象里面的属性和方法可以让所有的对象实例共享。prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 
    ```

22. vue生命周期

    ![img](https://img-blog.csdn.net/20180104113902663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ1MTE1Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

    ![这里写图片描述](https://img-blog.csdn.net/20180104113943794?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ1MTE1Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

23. vue组件中的updated，和watch那个会在组件更新的时候先触发

    ```
    updated钩子它的官方文档解释就是：组件更新之后，那么顾名思义，当前组件的数据发送变化的时候（任何一个当前组件data中的数据）就会触发updated。

    watch呢它主要用于监听一个数据，基本用在一个数据影响多个数据的情况下，这里不得不提到computed计算属性了，它正好和watch相反，是一个数据受多个数据影响；watch监听数据如果不设置“deep”深度监听的话，是无法监听到对象内部的数据变化。

    在触发的先后上，watch会先触发，因为watch触发是dom还未更新，updated实在组件更新之后，所以在dom更新后才会触发。

    所以显而易见，updated一般用在比如用户信息的任何一个信息发生改变，就更新其他地方的信息等等，而watch则是当某个数据改变会触发某些事件或某些改变等等，那么我们用它们的时候就要根据具体需求而定咯。
    ```

24. vue路由的实现原理

    https://segmentfault.com/a/1190000011967786

25. 问了一下es6 import模块导入问题例如：

    ```
     import {Button,Select} from 'element-ui'

     有前文可知import会先转换为commonjs即

              var a=require('element-ui');

              var b=a.Button;

              var c=a.Select;有此可知element-ui全部被引进了；

              所以babel-plugin-component就做了一件事将  import  {Button,Select} from 'element-ui'  转换成了

              import Button from "element-ui"; ui/lib/button

              import Select  from "element-ui"; ui/lib/select

    ```

26. Js 存储问题

    ```
    javaScript有三种数据存储方式，分别是：

    sessionStorage

    localStorage

    cookier

    相同点：都保存在浏览器端，同源的

    不同点：

    ①传递方式不同

    cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。

    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

    ②数据大小不同

    cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
    存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。

    sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

    ③数据有效期不同

    sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；

    localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；

    cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

    ④作用域不同

    sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；

    localStorage 在所有同源窗口中都是共享的；

    cookie也是在所有同源窗口中都是共享的。

    Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。
    Web Storage 的 api 接口使用更方便。
    ```

27. Gulp和Webpack前端自动化工具

28. 流式布局，自适应布局，响应式布局，弹性布局

    ```
    流式布局：页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。网页中主要的划分区域的尺寸用百分数。搭配min，max使用。
    自适应布局：分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部。使用@media媒体查询给不同尺寸和介质的设备切换不同的样式。
    弹性布局：使用rem/em单位进行相对布局。
    响应式布局：流式布局+媒体查询+弹性布局。
    ```

29. cookie session区别

30. 数据库的一些数据查询问题

31. 两个变量在不借助第三方变量的帮助下实现两个值交换，和一些物体碰撞算法。

32. 两个排序算法  

33. javascrip原型链的用法和作用，对闭包的理解，以用闭包的作用

34. 堆数据结构

35. promise

36. css盒子模型

37. http请求整个流程

38. 从地址栏输入地址到展现发生什么

39. web安全

40. react和vue有哪些不同 说说你对这两个框架的看法

    ```
    都用了virtual dom的方式, 性能都很好

    ui上都是组件化的写法，开发效率很高

    vue是双向数据绑定，react是单项数据绑定，当工程规模比较大时双向数据绑定会很难维护

    vue适合不会持续的  小型的web应用，使用vue.js能带来短期内较高的开发效率. 否则采用react

    ```

41. let和const的区别

42. 平时用了es6的哪些特性，体验如何 和es5有什么不同

43. 介绍一下你对webpack的理解，和gulp有什么不同

44. webpack打包速度慢，你觉得可能的原因是什么，该如何解决

45. http响应中content-type包含哪些内容

46. 浏览器缓存有哪些，通常缓存有哪几种方式

47. 如何取出一个数组里的图片并按顺序显示出来

48. 使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的

49. 介绍一下闭包和闭包常用场景

50. 为什么会出现闭包这种东西，解决了什么问题

51. 介绍一下你所了解的作用域链,作用域链的尽头是什么，为什么

52. 一个Ajax建立的过程是怎样的，主要用到哪些状态码

53. 使用promise封装

54. 知道语义化吗？说说你理解的语义化，如果是你，平时会怎么做来保证语义化

55. 说说content-box和border-box，为什么看起来content-box更合理，但是还是经常使用border-box

56. 介绍一下HTML5的新特性

57. 事件委托

58. 实现三个DIV等分排布在一行（考察border-box）

59. 说说你知道JavaScript的内存回收机制

60. 函数防抖和函数节流

61. 编程实现输出一个数组中第N大的数据实现两栏布局有哪些方法

62. 设置width的flex元素，flex属性值是多少

63. get和post有什么不同

64. 判断链表是否有环

65. 输出二叉树的最小深度

66. javaScript中的this是什么，有什么用，它的指向是什么

67. 全局代码中的this  是指向全局对象

68. 作为对象的方法调用时指向调用这个函数的对象。

69. 作为构造函数指向新创建的对象

70. 使用apply和call设置this

71. 写一个快速排序

72. 怎么实现从一个DIV左上角到右下角的移动，有哪些方法，都怎么实现

73. 简单介绍一下promise，他解决了什么问题

74. 写一个组合继承

75. 判断数组有哪些方法

    ```
    a instanceof Array

    a.constructor == Array

    Object.prototype.toString.call(a) == [Object Array]

    ```

76. 多页面通信有哪些方案，各有什么不同

77. 用Node实现一个用户上传文件的后台服务应该怎么做

    ```
    multer模块
    ```

78. XSS和CSRF攻击

    ```
    xss：比如在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS

    写一个脚本将cookie发送到外部服务器这就是xss攻击但是没有发生csrf

    防范：对输入内容做格式检查 输出的内容进行过滤或者转译

    CSRF：又称XSRF，冒充用户发起请求（在用户不知情的情况下）,完成一些违背用户意愿的请求 如恶意发帖，删帖

    比如在论坛发了一个删帖的api链接 用户点击链接后把自己文章给删了 这里就是csrf攻击没有发生xss

    防范：验证码 token 来源检测

    ```

79. 圣杯布局和双飞翼布局

80. 图片预加载和懒加载

81. UMD规范和ES6模块化，Commonjs的对比

82. 前端性能优化

83. 将url的查询参数解析成字典对象

84. 两个数组合并成一个数组排序返

85. 如何解决ajax无法后退的问题

    ```
    HTML5里引入了新的API

    即：history.pushState, history.replaceState

    可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。

    1. onpopstate监听后
    2. 实现一个once函数
    3. 分域名请求图片的原因和好处

    浏览器的并发请求数目限制是针对同一域名的，超过限制数目的请求会被阻塞

    浏览器并发请求有个数限制，分域名可以同时并发请求大量图片

    页面的加载顺序

    html顺序加载，其中js会阻塞后续dom和资源的加载，css不会阻塞dom和资源的加载但是会阻塞js的加载。

    浏览器会使用prefetch对引用的资源提前下载

    1.没有 defer 或 async，浏览器会立即加载并执行指定的脚本

    2.有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行(下载异步，执行同步，加载完就执行)。

    3.有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。
    ```

86. 计算机网络的分层概述

    ```
    tcp/ip模型：从下往上分别是链路层，网络层，传输层，应用层

    osi模型：从下往上分别是物理层，链路层，网络层，传输层，会话层，表示层，应用层。
    ```

87. jscss缓存问题

    ```
    浏览器缓存的意义在于提高了执行效率，但是也随之而来带来了一些问题，导致修改了js、css，客户端不能更新

    都加上了一个时间戳作为版本号

    <script type=”text/javascript” src=”{JS文件连接地址}?version=XXXXXXXX”></script>
    ```

88. setTimeout,setInterval,requestAnimationFrame之间的区别

89. webpack常用到哪些功能

    ```
    设置入口  设置输出目 设置loader  extract-text-webpack-plugin将css从js代码中抽出并合并 处理图片文字等功能 解析jsx解析bable
    ```

90. 介绍sass

    ```
    &定义变量 css嵌套 允许在代码中使用算式 支持if判断for循环
    ```

91. websocket和ajax轮询

    ```
    Websocket是HTML5中提出的新的协议，注意，这里是协议，可以实现客户端与服务器端的通信，实现服务器的推送功能。

    其优点就是，只要建立一次连接，就可以连续不断的得到服务器推送的消息，节省带宽和服务器端的压力。

    ajax轮询模拟长连接就是每个一段时间（0.5s）就向服务器发起ajax请求，查询服务器端是否有数据更新

    其缺点显而易见，每次都要建立HTTP连接，即使需要传输的数据非常少，所以这样很浪费带宽
    ```

92. tansition和margin的百分比根据什么计算

    ```
    transition是相对于自身,margin相对于参照物
    ```

93. es6的深度克隆

    ```
    IOS移动端click事件300ms的延迟响应

    一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了
    ```

94. 移动端兼容问题

95. js基本类型及判断方法

96.  meta属性

97. 三次握手四次挥手